RabbitMQ整体模型架构

![](D:\RabbitMQ学习之路\image\model.png)

### 1.生产者与消费者

在RabbitMQ中，生产者（Producer）和消费者（Consumer）是消息的发送者和接收者，两者共同参与消息的传递和处理。

生产者（Producer）是消息的发送方。它负责创建并发送消息到RabbitMQ的消息队列中。生产者将消息发送到特定的交换机（Exchange），并指定一个路由键（Routing Key）来标识消息的目标队列。生产者可以发送不同类型的消息，如文本、JSON、二进制数据等。生产者可以根据业务需求和消息队列的配置选择发送消息的持久性、优先级等属性。

消费者（Consumer）是消息的接收方。它从RabbitMQ的消息队列中订阅并接收消息。消费者会监听指定的队列，并在有新消息到达时进行消费处理。消费者可以按照一定的策略获取消息，如轮询、公平分发等。消费者接收到消息后，会进行相应的业务处理，如数据处理、逻辑计算、持久化等。

### 2.Broker

在RabbitMQ中，Broker是指消息中间件的核心组件，它负责接收、路由和传递消息。作为一个消息代理，RabbitMQ的Broker扮演着关键的角色，确保消息的可靠传递和处理。

RabbitMQ的Broker由以下几个主要组件组成：

1. Exchange（交换机）：Exchange是消息的路由器，负责接收生产者发送的消息，并根据预定义的规则将消息路由到一个或多个队列中。Exchange根据消息的路由键（Routing Key）和绑定键（Binding Key）决定将消息发送到哪个队列。

2. Queue（队列）：Queue是消息的缓冲区，用于存储待处理的消息。消费者从队列中订阅并接收消息。每个队列都有一个唯一的名称，生产者将消息发送到指定的队列。

3. Binding（绑定）：绑定将交换机和队列关联起来，定义了消息的路由规则。绑定规则通常是基于交换机类型和路由键来匹配消息，并将其发送到相应的队列。

4. Connection（连接）：连接是生产者、消费者和Broker之间的网络连接。生产者和消费者通过连接与Broker进行通信。每个连接可以同时支持多个通道（Channel）。

5. Channel（通道）：通道是在连接上创建的虚拟连接，用于在客户端和Broker之间进行消息的传输。通道是轻量级的，可以并发地处理多个消息流，避免了每个消息都建立独立的连接的开销。

### 2.1 队列

在RabbitMQ中，队列（Queue）是存储消息的缓冲区，它是生产者和消费者之间的桥梁。队列在RabbitMQ中起到了关键的作用，用于存储待处理的消息，并确保它们按照特定的顺序和规则进行消费。

以下是一些关于RabbitMQ队列的重要特性和概念：

1. 队列名称：每个队列在RabbitMQ中都有一个唯一的名称。生产者将消息发送到指定的队列，而消费者则从队列中订阅并接收消息。

2. 消息存储：队列中的消息可以持久化或非持久化存储。持久化的消息在RabbitMQ重启后仍然可用，而非持久化的消息在重启后会被丢弃。

3. 消息优先级：RabbitMQ允许为消息设置优先级。优先级高的消息将在队列中优先被消费。

4. 消费者竞争：队列中的消息可以同时被多个消费者竞争消费。RabbitMQ使用一种公平分发（Fair Dispatch）的机制，确保每个消费者平均地接收到消息，避免某个消费者处理过多的消息而导致不平衡。

5. 消息确认：消费者在处理完一条消息后，可以向RabbitMQ发送确认消息，表示该消息已经成功处理。如果消费者在处理消息时发生错误，消息可以重新进入队列或被丢弃，具体取决于消费者的配置。

6. 队列绑定：队列可以与交换机（Exchange）进行绑定，以定义消息的路由规则。绑定规则通常是基于交换机类型和路由键来匹配消息，并将其发送到相应的队列。

7. 队列属性：队列还具有一些其他属性，如最大长度限制、消息过期时间、死信队列等。这些属性可以根据业务需求进行配置，以控制队列的行为和性能。

### 2.2 交换器，路由键，绑定

1. 交换器（Exchange）：交换器是消息的路由器，它接收生产者发送的消息，并根据预定义的规则将消息路由到一个或多个队列中。交换器负责接收生产者发送的消息，并根据消息的路由键进行路由决策。RabbitMQ提供了几种不同类型的交换器，包括直连交换器（Direct Exchange）、主题交换器（Topic Exchange）、扇形交换器（Fanout Exchange）和头交换器（Headers Exchange），每种类型的交换器都有不同的路由规则和行为。
   
   1. 直连交换器（Direct Exchange）：  
      直连交换器是最简单的交换器类型之一，它使用消息的路由键（Routing Key）与队列的绑定键（Binding Key）进行完全匹配。当一个消息的路由键与某个绑定键完全匹配时，该消息将被路由到与该绑定关联的队列中。直连交换器可以实现点对点的消息传递。**如果没有队列与绑定键完全匹配，消息将被丢弃。** 直连交换器适用于简单的消息路由场景。
   
   2. *主题交换器（Topic Exchange）：  
      主题交换器使用通配符模式来进行消息路由。它通过将消息的路由键和队列的绑定键进行模式匹配，将消息路由到符合模式匹配规则的队列中。**在topic交换器类型下RoutingKey和BindKey之间做模糊查询。** 主题交换器支持两种通配符：*（星号）表示匹配一个单词，#（井号）表示匹配零个或多个单词。通过使用不同的绑定键和路由键模式，主题交换器可以实现灵活的消息路由，适用于多样化的消息分发需求。
   
   3. 扇形交换器（Fanout Exchange）：  
      扇形交换器将消息广播到与其绑定的所有队列中。它忽略消息的路由键，只需将消息复制到所有与之绑定的队列中。无论绑定键的值如何，消息都会被广播到所有队列。扇形交换器适用于广播消息到多个消费者的场景，其中每个消费者都需要获得相同的消息副本。
   
   4. 头交换器（Headers Exchange）：  
      头交换器使用消息的头部信息进行匹配和路由。头部信息是由生产者在消息中设置的一组键值对。在绑定队列时，可以指定一组键值对的匹配规则。当消息的头部信息与绑定规则相匹配时，消息将被路由到相应的队列中。头交换器提供了高度灵活的路由规则，但较少使用，因为它对消息的头部信息进行了复杂的匹配，性能较低。

2. 路由键（Routing Key）：路由键是生产者在发送消息时附加的一个属性，用于指定消息的目标队列或交换器。路由键是一个字符串，生产者根据业务需求为消息设置路由键。在直连交换器和主题交换器中，路由键用于匹配交换器与队列之间的绑定规则，决定消息将被路由到哪个队列。不同的交换器类型对路由键的匹配方式有所不同。需要和绑定键联合使用才能生效

3. 绑定（Binding）：绑定将交换器和队列关联起来，定义了消息的路由规则。绑定规则通常是基于交换器类型和路由键来匹配消息，并将其发送到相应的队列。绑定是通过在交换器和队列之间建立关系来实现的，一般由消费者在消费者端创建。一个队列可以与多个交换器进行绑定，也可以绑定多个队列到同一个交换器上。绑定规则决定了消息如何在交换器和队列之间进行路由和分发。
   
   生产者将消息发送给交换器时，需要一个RoutingKey，交换器通过BindingKey和RoutingKey匹配来决定消息会被路由到哪个队列，BindKey不是在所有情况都生效，它依赖交换器的类型，例如，fanout类型的交换器就会无视BindKey，将消息路由到所有绑定到该交换器的队列中

# 3.RabbitMQ的运行流程

1. 生产者
   
   1. 生产者连接到RabbitMQ Broker，建立一个连接（connection），开启一个信道（channel）
   
   2. 生产者声明一个交换器，并设置相关属性，比如类型，是否持久化等
   
   3. 生产者声明一个队列，并设置相关属性，比如是否排他，是否持久化，是否自动删除等
   
   4. 生产者通过路由键将交换器和队列绑定起来
   
   5. 生产者将消息发送到broker，其中包含路由键，交换器等信息
   
   6. 相应的交换器根据接收的路由键查找相匹配的队列
   
   7. 如果找到，则把从生产者发送的消息存入队列
   
   8. 没有找到，就根据生产者配置选择丢弃还是回退给生产者
   
   9. 关闭信道
   
   10. 关闭连接

2. 消费者
   
   1. 消费者连接到RabbitMQ Broker，建立一个连接（connection），开启一个信道（channel）
   
   2. 消费者声明一个队列，并设置相关属性，比如是否排他，是否持久化，是否自动删除等，这是为了不知道消费者和生产者谁先连接到broker，万一队列还没建立而出问题的兜底方案，并不会产生两个队列
   
   3. 消费者向broker请求相应队列中的消息，可能会设置相应的回调函数来处理消息
   
   4. 等待broker回应并投递消息，消费者接收消息
   
   5. 消费者确认(ack)消息
   
   6. RabbitMQ从队列中删除已经被确认的消息
   
   7. 关闭信道
   
   8. 关闭连接
